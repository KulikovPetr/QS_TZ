"""
Здравствуйте, меня зовут Петр. Здесь я поделюсь мыслями о тестовом задании и коротко прорезюмирую решение.
Само решение представлено ниже. Я специально не выделил комментарий в Readme, чтобы Вы его точно прочли.

Task 1: Grid Representation
Основная проблема - выбрать алгоритм заполнения сетки. Я выбрал случайную генерацию пар координат и сохранение их в множество.
Использование структуры данных "множество" избавляет от необходимости проверки повторения пары координат, поскольку
множество не может содержать дубликаты. Такой алгоритм имеет линейную сложность, но наличие фактора случайности портит картину.
Можно решить эту задачу создав всевозможные пары координат, перемешать список с ними и взять нужное количество.
Такой алгоритм имеет большую сложность (N^2) и требует больше памяти. Зато не зависит от генерации случайных чисел

Task 2: Tower Coverage
Тут бы я предложил использовать не плоскость(grid) а трехмерный массив. На первом уровне оставить открытые и блокированные
клетки и вышки, а на втором уровне(слое) располагать покрытие вышек. Но в ТЗ нужно работать с Grid, поэтому и работал с
друмерным массивом. В принципе, сложностей нет. Ставим вышку и в квадрате "вокруг" неё ставим покрытие.

Task 3: Optimization Problem
Уже сложная задача, несколько конфликтующая c Task 4. Если располагать минимум вышек, они (в идеале) не будут пере-
крывать друг друга, из-за чего поиск пути между ними будет невозможен.
Но есть более сложная задача - расставить их логично. Так, в моем решении, они ставятся даже у краев, что неоптимально.
Написание оптимального алгоритма с минимизацией вышек я бы совместил с bonus task 1, а пока что сделал неоптимальный
и "ленивый" алгоритм.
UPD: реализовал для неё альтернативное решение в виде жадного алгоритма.

Task 4: Path Reliability
Эта задача конфликтует с предыдущей. Чтобы добиться минимума башен, необходимо, чтобы своими радиусами они лишь касались.
В таком случае, между ними невозможно найти путь. Я устанавливал башни в Task 3 специально не оптимально(чтобы они
пересекались радиусами), и добавил(возможно лишнее) условие, что если они касаются радиусами(а не находятся в радиусе),
то между ними есть связь. Если такое решение не подходит, окей, можно немного изменить алгоритм размещения башен из Task 3

Task 5: Visualization
Здесь все просто:
1. Отображение сетки города изначально с препятствиями и зонами, которые необходимо покрыть.
2. Отображение города с покрытием и вышками (и препятствиями, если процент застройки высокий).
3. Отображение пути из одной вышки в другую.
Использовал Matplotlib. Не знаю, что ещё писать.

Bonus tasks (optional):
1. Это уже NP задача, для её решения нужно хорошо подумать и потратить ещё день-два на её решение. Решение предыдущих
задач заняло у меня прилично времени, и я предпочел отправить задание без её решения.
UPD: реализовал для её решения жадный алгоритм.

2. Тут уже точно нужно использовать трехмерный массив. Причем я бы предложил для вышки с каждым уровнем сигнала для ка-
ждого уровня сигнала использовать соответствующий "уровень" в массиве, для чистоты ришения. Ну и это просто задача сложнее,
чем предыдущая.
"""



import numpy as np
import random
import matplotlib.pyplot as plt
import networkx as nx



class city_grid:
    # Инициализация класса
    def __init__(self, rows, cols, coverage=0.3):
        self.rows = rows
        self.cols = cols
        self.grid = np.zeros((rows, cols), dtype=int)  # сетка заполняется нулями, означающими свободное пространство
        self.towers_coords = []  # список для сохранения координат вышек

        self.build_obstructed_blocks(coverage)  # расстановка блоков-препятствий

    # метод для создания покрытия сетки препятствиями. Алгоритм далеко не идеальный,
    # но у него линейная сложность, так что не такой уж и плохой.
    def build_obstructed_blocks(self, coverage=0.3):

        total_obsacles = int(self.rows * self.cols * coverage)  # вычисление, сколько всего препятствий надо расставить

        unique_pairs = set()  # множество пар координат препятствий. Выбрано именно множество, чтобы не перепроверять вхождение пары каждый раз
        while len(unique_pairs) < total_obsacles:
            a = random.randint(0, self.rows-1)
            b = random.randint(0, self.cols-1)

            pair = (a, b)
            unique_pairs.add(pair)

        for item in unique_pairs:
            self.grid[item[0]][item[1]] = 1  # заполнение сетки препятствиями

        print(self.grid)  # отрисовка сетки в консоли для проверки

    # метод для установки башни. Принимает две координаты и радиус.
    def build_tower(self, x,y,R):

        # проверка при установке башни у границ сетки, чтобы не выйти за пределы
        # убрал бесполезную функцию, проверки, ведь есть функции min и max
        self.grid[max(0,x-R):min(x+R+1, self.grid.shape[0]), max(0,y-R):min(y+R+1, self.grid.shape[1])] = 2  # заполнение клеток в квадрате двойками - значением покрытия
        self.grid[x, y] = 3  # и только потом устанавливается сама вышка
        self.towers_coords.append((x,y))  # вышка сохраняется в списке
        self.update_towers()  # повторно отрисовываются все вышки

    # метод для повторной отрисовки вышек. Ведь после установки очередной вышки она может перекрыть другие.
    def update_towers(self):
        for item in self.towers_coords:
            self.grid[item[0], item[1]] = 3

    # В Task 3 не было указано, что вышки стоит располагать супер эффективно.
    # Минимальное количество вышек - это NP-полная задача, поэтому пока что предоставляю далеко не оптимальное решение
    # Так он просто ставит башни подряд, если встречается непокрытый участок.
    # Кроме того, установка именно МИНИМУМА башен сразу делает невозможным поиск пути между ними, поскольку ни одна вышка
    # не будет доставать до другой, а лишь едва касаться радиусами.
    def optimization_problem(self, R):
        for i in range(0, (self.grid.shape[0])):
            for j in range(0, (self.grid.shape[1])):
                if self.grid[i][j] == 0:
                    self.build_tower(i,j,R)

    # Альтернативное решение для Task 3 и для Bonus Task 1. Реализация жадного алгоритма для постановки башен.
    # Да, неэффективного, но какого-то минимального решения. К слову, весьма неплохого для установки маленького
    # количества башен на весьма разреженной сетке. Жадный алгоритм самый примитивный, но и он имеет место быть.
    def optimization_problem_greedy_algorithm(self, R, towers):

        # пока все ещё остались башни, выполняется цикл:
        while towers != 0:

            max_pos = (0,0)  # координата постановки башни
            max_blocks = 0  # количество пустых клеток вокруг башни

            # грубо перебираются все ячейки массива. Для каждой подсчитывается, сколько вокруг неё свободных клеток
            for x in range(0, (self.grid.shape[0])):
                for y in range(0, (self.grid.shape[1])):
                    # подсчёт количества свободных клеток
                    result = np.where(self.grid[max(0,x-R):min(x+R+1, self.grid.shape[0]), max(0,y-R):min(y+R+1, self.grid.shape[1])] == 0)
                    list_of_coordinates= (list(zip(result[0], result[1])))
                    # проверка значений, лучше ли это место для постановки башни
                    if max_blocks < len(list_of_coordinates):
                        max_blocks = len(list_of_coordinates)
                        max_pos = (x,y)
            # установка башни в лучшее место из доступных
            self.build_tower(max_pos[0], max_pos[1], R)
            print("поставил башню на: ", max_pos)
            towers -= 1
            # проверка, остались ли пустые клетки после установки башни
            result = np.where(self.grid == 0)
            list_of_coordinates= (list(zip(result[0], result[1])))
            if len(list_of_coordinates) == 0:
                break
        print("осталось башен: ", towers)

    # бонусный метод, не используемый в данном коде.
    # Используется для частичного решения задачи минимизации башен - построение первой башни в радиусе от
    # (0,0) угла, если там есть хоть одна непокрытая клетка.
    def first_tower_set(self, R):
        if np.sum(self.grid[0:R,0:R]) > 0:
            if self.grid[R,R] != 1:
                self.build_tower(R,R,R)
            else:
                for x in range (R, 0, -1):
                    for y in range (R, 0, -1):
                        if self.grid[x,y] != 1:
                            self.build_tower(x,y,R)
                            return
        result = np.where(self.grid == 0)
        list_of_coordinates= list(zip(result[0], result[1]))
        self.build_tower(list_of_coordinates[0][0], list_of_coordinates[0][1], R)

    def graph_builder(self,x1,y1,x2,y2, R):

        G = nx.Graph()  # инициализация графа

        # создание списка координат башен
        result = np.where(self.grid == 3)
        list_of_coordinates= (list(zip(result[0], result[1])))
        print ("список координат башен:", list_of_coordinates)

        # Создание ребер графа. Для сохранения логики, предположим, что вышка считается доступной для другой,
        # если касается её поля покрытия. Опять же, противоречие с задачей минимализации количества башен.
        for item_1 in list_of_coordinates:
            for item_2 in list_of_coordinates:
                if item_1 != item_2:
                    if abs(item_1[0]-item_2[0]) <= R+1 and abs(item_1[1]-item_2[1]) <= R+1:
                        # сохранение узлов и ребер в граф
                        G.add_node(item_1)
                        G.add_edge(item_1,item_2)

        # путь не всегда возможно построить, поэтому и ставим проверку
        try:
            # Использовал алгоритм поиска пути из библиотеки networkx, чтобы не изобретать велосипед.
            # Не в том ли прелесть питона, что в его библиотеках уже написано все, что нужно?
            shortest_path = nx.shortest_path(G, source=(x1,y1), target=(x2,y2))
            print("Кратчайший путь:", shortest_path)
            return shortest_path

        except:
            print(f"Невозможно проложить путь из {(x1,y1)} в {(x2,y2)}.")
            return None


    # метод визуализации сетки и пути
    def grid_visualisation(self, path = None):

        fig = plt.figure()
        ax = fig.add_subplot()
        ax.set_title('0 - cвободно, 1 - занято, 2 - покрыто, 3 - вышка')

        plt.imshow(self.grid, cmap='magma')
        plt.colorbar()

        # построение пути, если необходим
        if path != None:
            list_x = []
            list_y = []
            for item in path:
                list_x.append(item[1])
                list_y.append(item[0])
            plt.plot(list_x, list_y)

        plt.show()

# пример использования программы
city_grid_example = city_grid(10,20)  # создание экземпляра класса карты города
city_grid_example.grid_visualisation()   # визуализация карты города до расстановки башен
city_grid_example.optimization_problem(3)  # расстановка в городе башен с радиусом 3

# установка двух башен, между которыми будем искать путь
city_grid_example.build_tower(8,16,3)
city_grid_example.build_tower(1,1,3)

# визуализация карты с изображением пути между двумя башнями
city_grid_example.grid_visualisation(city_grid_example.graph_builder(8,16, 1, 1, 3))

# пример работы жадного алгоритма постановки башен:
city_grid_example_2 = city_grid(10,20)
city_grid_example_2.grid_visualisation()
city_grid_example_2.optimization_problem_greedy_algorithm(3, 4) # вызов метода для установки 4 башен радиуса 3
city_grid_example_2.grid_visualisation()
print("done")